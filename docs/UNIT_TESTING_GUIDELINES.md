# Руководство по юнит-тестированию

В этом документе описаны лучшие практики написания юнит-тестов на основе шаблонов тестовых двойников (Test Doubles Patterns) и паттерна Arrange-Act-Assert.

## 1. Шаблоны тестовых двойников

- **Test Stub**: возвращает фиксированные данные. Пример: stub платежного шлюза всегда возвращает `true`.
- **Test Spy**: оборачивает реальный объект для записи вызовов. Используйте для проверки взаимодействий.
- **Mock Object**: позволяет настраивать ответы и проверять вызовы через методы `mockResolvedValue`, `toHaveBeenCalledWith()`.
- **Fake Object**: упрощённая in-memory реализация зависимости с базовой логикой (например, in-memory база данных).
- **Configurable Test Double**: расширяемый double, конфигурируемый в тестах для разных сценариев.
- **Hard-Coded Test Double**: stub с жёстко зашитыми ответами, не изменяемыми во время теста.
- **Test-Specific Subclass**: подкласс, особым образом реализующий методы для конкретного теста.

## 2. Паттерн Arrange-Act-Assert

1. **Arrange**: подготовьте все входные данные и окружение для теста.
2. **Act**: выполните действие, которое тестируете.
3. **Assert**: проверьте результат через `expect`.

Каждый тест должен чётко отделять эти три шага и содержать не более одного блока `Act-Assert`.

## 3. Общие рекомендации

- Изолируйте юнит-тесты от внешних сервисов через stubs или fakes.
- Моки используйте только тогда, когда нужно проверить взаимодействие с зависимостью.
- Не смешивайте логику теста: один тест — одна функциональность.
- Используйте одинаковый стиль именования: `should_<что_должно_произойти>`. 
- Не оставляйте в тестах `console.log` и side-effects.

## 4. Примеры использования

```typescript
// Arrange
const stubGateway = new StubPaymentGateway();
const service = new OrderService(stubGateway);

// Act
const result = await service.processOrder(100);

// Assert
expect(result).toBe('Payment Successful');
```

```typescript
// Example of Fake database
class FakeRepo implements UserRepo { ... }
```

