// 🧪 Unit тесты для mock режима подписок
import {
    addMockSubscription,
    clearMockSubscriptions,
    mockCancelSubscription,
    mockCreateSubscription,
    mockGetSubscription,
    mockGetSubscriptionPlans,
    mockGetSubscriptionStatus,
    mockUpdateSubscription
} from '@/lib/subscription-mock'
import { Subscription, SubscriptionTier } from '@/types'

// Mock console.log для проверки логов
let mockConsoleLog: jest.SpyInstance

describe('Subscription Mock Functions', () => {
    const mockUserId = 'mock-user-1'

    beforeEach(() => {
        clearMockSubscriptions()
        mockConsoleLog = jest.spyOn(console, 'log').mockImplementation()
    })

    afterEach(() => {
        mockConsoleLog.mockRestore()
    })

    describe('mockGetSubscription', () => {
        it('должен вернуть ошибку для пользователя без подписки', async () => {
            const result = await mockGetSubscription(mockUserId)

            expect(result.success).toBe(false)
            expect(result.error).toBe('Подписка не найдена')
        })

        it('должен вернуть подписку существующего пользователя', async () => {
            // Создаем подписку
            await mockCreateSubscription(mockUserId, 'free')

            const result = await mockGetSubscription(mockUserId)

            expect(result.success).toBe(true)
            expect(result.subscription).toBeDefined()
            expect(result.subscription?.userId).toBe(mockUserId)
            expect(result.subscription?.tier).toBe('free')
        })

        it('должен логировать действие', async () => {
            await mockGetSubscription(mockUserId)

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Получение подписки без реальных запросов к Supabase'
            )
        })
    })

    describe('mockCreateSubscription', () => {
        it('должен успешно создать новую подписку', async () => {
            const result = await mockCreateSubscription(mockUserId, 'premium')

            expect(result.success).toBe(true)
            expect(result.subscription).toBeDefined()
            expect(result.subscription?.userId).toBe(mockUserId)
            expect(result.subscription?.tier).toBe('premium')
            expect(result.subscription?.status).toBe('active')
            expect(result.subscription?.id).toMatch(/^mock-sub-\d+-[a-z0-9]+$/)
        })

        it('должен установить правильные временные периоды', async () => {
            const beforeCreate = new Date()
            const result = await mockCreateSubscription(mockUserId, 'free')
            const afterCreate = new Date()

            expect(result.subscription?.currentPeriodStart).toBeInstanceOf(Date)
            expect(result.subscription?.currentPeriodEnd).toBeInstanceOf(Date)
            expect(result.subscription?.currentPeriodStart.getTime()).toBeGreaterThanOrEqual(beforeCreate.getTime())
            expect(result.subscription?.currentPeriodStart.getTime()).toBeLessThanOrEqual(afterCreate.getTime())

            // Проверяем, что период заканчивается через месяц
            const expectedEnd = new Date(result.subscription?.currentPeriodStart || 0)
            expectedEnd.setMonth(expectedEnd.getMonth() + 1)
            expect(result.subscription?.currentPeriodEnd?.getTime()).toBeCloseTo(expectedEnd.getTime(), -3) // Точность до секунды
        })

        it('должен вернуть ошибку при попытке создать вторую подписку', async () => {
            // Создаем первую подписку
            await mockCreateSubscription(mockUserId, 'free')

            // Пытаемся создать вторую подписку
            const result = await mockCreateSubscription(mockUserId, 'premium')

            expect(result.success).toBe(false)
            expect(result.error).toBe('У пользователя уже есть активная подписка')
        })

        it('должен установить cancelAtPeriodEnd в false по умолчанию', async () => {
            const result = await mockCreateSubscription(mockUserId, 'pro')

            expect(result.subscription?.cancelAtPeriodEnd).toBe(false)
        })

        it('должен логировать действие', async () => {
            await mockCreateSubscription(mockUserId, 'free')

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Создание подписки без реальных запросов к Supabase'
            )
        })
    })

    describe('mockUpdateSubscription', () => {
        let subscriptionId: string

        beforeEach(async () => {
            const result = await mockCreateSubscription(mockUserId, 'free')
            subscriptionId = result.subscription?.id || ''
        })

        it('должен успешно обновить существующую подписку', async () => {
            const updates = {
                tier: 'premium' as SubscriptionTier,
                cancelAtPeriodEnd: true
            }

            const result = await mockUpdateSubscription(subscriptionId, updates)

            expect(result.success).toBe(true)
            expect(result.subscription?.tier).toBe('premium')
            expect(result.subscription?.cancelAtPeriodEnd).toBe(true)
        })

        it('должен обновить временную метку updatedAt', async () => {
            const originalUpdatedAt = new Date()

            // Ждем немного, чтобы время изменилось
            await new Promise(resolve => setTimeout(resolve, 10))

            const updates = { tier: 'premium' as SubscriptionTier }
            const result = await mockUpdateSubscription(subscriptionId, updates)

            expect(result.subscription?.updatedAt.getTime()).toBeGreaterThan(originalUpdatedAt.getTime())
        })

        it('должен вернуть ошибку для несуществующей подписки', async () => {
            const updates = { tier: 'premium' as SubscriptionTier }
            const result = await mockUpdateSubscription('non-existent-id', updates)

            expect(result.success).toBe(false)
            expect(result.error).toBe('Подписка не найдена')
        })

        it('должен логировать действие', async () => {
            const updates = { tier: 'premium' as SubscriptionTier }
            await mockUpdateSubscription(subscriptionId, updates)

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Обновление подписки без реальных запросов к Supabase'
            )
        })
    })

    describe('mockCancelSubscription', () => {
        let subscriptionId: string

        beforeEach(async () => {
            const result = await mockCreateSubscription(mockUserId, 'premium')
            subscriptionId = result.subscription?.id || ''
        })

        it('должен успешно отменить подписку', async () => {
            const result = await mockCancelSubscription(subscriptionId)

            expect(result.success).toBe(true)
            expect(result.subscription?.status).toBe('canceled')
            expect(result.subscription?.cancelAtPeriodEnd).toBe(true)
        })

        it('должен обновить временную метку updatedAt', async () => {
            const originalUpdatedAt = new Date()

            await new Promise(resolve => setTimeout(resolve, 10))

            const result = await mockCancelSubscription(subscriptionId)

            expect(result.subscription?.updatedAt.getTime()).toBeGreaterThan(originalUpdatedAt.getTime())
        })

        it('должен вернуть ошибку для несуществующей подписки', async () => {
            const result = await mockCancelSubscription('non-existent-id')

            expect(result.success).toBe(false)
            expect(result.error).toBe('Подписка не найдена')
        })

        it('должен логировать действие', async () => {
            await mockCancelSubscription(subscriptionId)

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Отмена подписки без реальных запросов к Supabase'
            )
        })
    })

    describe('mockGetSubscriptionPlans', () => {
        it('должен вернуть все активные планы подписок', async () => {
            const result = await mockGetSubscriptionPlans()

            expect(result.success).toBe(true)
            expect(result.plans).toBeDefined()
            expect(result.plans).toHaveLength(3) // free, premium, pro

            const planNames = result.plans?.map(plan => plan.name) || []
            expect(planNames).toContain('Free')
            expect(planNames).toContain('Premium')
            expect(planNames).toContain('Pro')
        })

        it('должен вернуть планы с правильной структурой данных', async () => {
            const result = await mockGetSubscriptionPlans()

            expect(result.success).toBe(true)
            expect(result.plans).toBeDefined()

            const freePlan = result.plans?.find(plan => plan.tier === 'free')
            expect(freePlan).toMatchObject({
                id: 'plan-free',
                name: 'Free',
                tier: 'free',
                price: 0,
                currency: 'RUB',
                interval: 'month',
                isActive: true
            })

            const premiumPlan = result.plans?.find(plan => plan.tier === 'premium')
            expect(premiumPlan).toMatchObject({
                id: 'plan-premium',
                name: 'Premium',
                tier: 'premium',
                price: 99900, // 999 рублей в копейках
                currency: 'RUB',
                interval: 'month',
                isActive: true
            })

            const proPlan = result.plans?.find(plan => plan.tier === 'pro')
            expect(proPlan).toMatchObject({
                id: 'plan-pro',
                name: 'Pro',
                tier: 'pro',
                price: 199900, // 1999 рублей в копейках
                currency: 'RUB',
                interval: 'month',
                isActive: true
            })
        })

        it('должен вернуть планы с правильными лимитами', async () => {
            const result = await mockGetSubscriptionPlans()

            const freePlan = result.plans?.find(plan => plan.tier === 'free')
            expect(freePlan?.limits).toMatchObject({
                tasks: 50,
                aiRequests: 10,
                storage: 100
            })

            const premiumPlan = result.plans?.find(plan => plan.tier === 'premium')
            expect(premiumPlan?.limits).toMatchObject({
                tasks: 500,
                aiRequests: 100,
                storage: 1000
            })

            const proPlan = result.plans?.find(plan => plan.tier === 'pro')
            expect(proPlan?.limits).toMatchObject({
                tasks: -1, // -1 означает неограниченно
                aiRequests: -1,
                storage: 10000
            })
        })

        it('должен вернуть планы с правильными функциями', async () => {
            const result = await mockGetSubscriptionPlans()

            const freePlan = result.plans?.find(plan => plan.tier === 'free')
            expect(freePlan?.features).toContain('До 50 задач в месяц')
            expect(freePlan?.features).toContain('Базовое планирование')
            expect(freePlan?.features).toContain('Email поддержка')

            const premiumPlan = result.plans?.find(plan => plan.tier === 'premium')
            expect(premiumPlan?.features).toContain('До 500 задач в месяц')
            expect(premiumPlan?.features).toContain('ИИ планировщик')
            expect(premiumPlan?.features).toContain('Приоритетная поддержка')
            expect(premiumPlan?.features).toContain('Аналитика продуктивности')

            const proPlan = result.plans?.find(plan => plan.tier === 'pro')
            expect(proPlan?.features).toContain('Неограниченные задачи')
            expect(proPlan?.features).toContain('Все ИИ модели')
            expect(proPlan?.features).toContain('Персональный менеджер')
            expect(proPlan?.features).toContain('API доступ')
            expect(proPlan?.features).toContain('Интеграции')
        })

        it('должен логировать действие', async () => {
            await mockGetSubscriptionPlans()

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Получение планов подписок без реальных запросов к Supabase'
            )
        })
    })

    describe('mockGetSubscriptionStatus', () => {
        it('должен вернуть ошибку для пользователя без подписки', async () => {
            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(false)
            expect(result.error).toBe('Подписка не найдена')
        })

        it('должен вернуть статус активной подписки', async () => {
            await mockCreateSubscription(mockUserId, 'premium')

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(true)
            expect(result.status).toBeDefined()
            expect(result.status?.tier).toBe('premium')
            expect(result.status?.status).toBe('active')
            expect(result.status?.isActive).toBe(true)
            expect(result.status?.canUpgrade).toBe(true)
            expect(result.status?.canDowngrade).toBe(true)
        })

        it('должен вернуть правильные лимиты для free плана', async () => {
            await mockCreateSubscription(mockUserId, 'free')

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(true)
            expect(result.status?.limits).toMatchObject({
                tasks: 50,
                aiRequests: 10,
                storage: 100
            })
        })

        it('должен вернуть правильные лимиты для premium плана', async () => {
            await mockCreateSubscription(mockUserId, 'premium')

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(true)
            expect(result.status?.limits).toMatchObject({
                tasks: 500,
                aiRequests: 100,
                storage: 1000
            })
        })

        it('должен вернуть правильные лимиты для pro плана', async () => {
            await mockCreateSubscription(mockUserId, 'pro')

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(true)
            expect(result.status?.limits).toMatchObject({
                tasks: -1, // -1 означает неограниченно
                aiRequests: -1,
                storage: 10000
            })
        })

        it('должен вернуть mock использование', async () => {
            await mockCreateSubscription(mockUserId, 'premium')

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(true)
            expect(result.status?.usage).toMatchObject({
                tasks: 15,
                aiRequests: 3,
                storage: 25
            })
        })

        it('должен определить canUpgrade правильно', async () => {
            // Free план может быть обновлен
            await mockCreateSubscription(mockUserId, 'free')
            let result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canUpgrade).toBe(true)

            // Premium план может быть обновлен
            clearMockSubscriptions()
            await mockCreateSubscription(mockUserId, 'premium')
            result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canUpgrade).toBe(true)

            // Pro план не может быть обновлен
            clearMockSubscriptions()
            await mockCreateSubscription(mockUserId, 'pro')
            result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canUpgrade).toBe(false)
        })

        it('должен определить canDowngrade правильно', async () => {
            // Free план не может быть понижен
            await mockCreateSubscription(mockUserId, 'free')
            let result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canDowngrade).toBe(false)

            // Premium план может быть понижен
            clearMockSubscriptions()
            await mockCreateSubscription(mockUserId, 'premium')
            result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canDowngrade).toBe(true)

            // Pro план может быть понижен
            clearMockSubscriptions()
            await mockCreateSubscription(mockUserId, 'pro')
            result = await mockGetSubscriptionStatus(mockUserId)
            expect(result.status?.canDowngrade).toBe(true)
        })

        it('должен вернуть ошибку для несуществующего плана', async () => {
            // Создаем подписку с несуществующим планом (это не должно произойти в реальности)
            addMockSubscription({
                id: 'test-sub',
                userId: mockUserId,
                tier: 'invalid' as SubscriptionTier,
                status: 'active',
                currentPeriodStart: new Date(),
                currentPeriodEnd: new Date(),
                cancelAtPeriodEnd: false,
                createdAt: new Date(),
                updatedAt: new Date()
            })

            const result = await mockGetSubscriptionStatus(mockUserId)

            expect(result.success).toBe(false)
            expect(result.error).toBe('План подписки не найден')
        })

        it('должен логировать действие', async () => {
            await mockCreateSubscription(mockUserId, 'free')
            await mockGetSubscriptionStatus(mockUserId)

            expect(mockConsoleLog).toHaveBeenCalledWith(
                '🧪 MOCK РЕЖИМ: Получение статуса подписки без реальных запросов к Supabase'
            )
        })
    })

    describe('Вспомогательные функции', () => {
        describe('clearMockSubscriptions', () => {
            it('должен очистить все mock подписки', async () => {
                await mockCreateSubscription(mockUserId, 'free')
                expect(await mockGetSubscription(mockUserId)).toMatchObject({ success: true })

                clearMockSubscriptions()
                expect(await mockGetSubscription(mockUserId)).toMatchObject({ success: false })
            })

            it('должен логировать действие', () => {
                clearMockSubscriptions()

                expect(mockConsoleLog).toHaveBeenCalledWith(
                    '🧪 MOCK РЕЖИМ: Очистка mock подписок'
                )
            })
        })

        describe('addMockSubscription', () => {
            it('должен добавить подписку в mock данные', () => {
                const subscription: Subscription = {
                    id: 'test-sub',
                    userId: mockUserId,
                    tier: 'premium',
                    status: 'active',
                    currentPeriodStart: new Date(),
                    currentPeriodEnd: new Date(),
                    cancelAtPeriodEnd: false,
                    createdAt: new Date(),
                    updatedAt: new Date()
                }

                addMockSubscription(subscription)

                // Проверяем, что подписка добавлена
                mockGetSubscription(mockUserId).then(result => {
                    expect(result.success).toBe(true)
                    expect(result.subscription?.id).toBe('test-sub')
                })
            })

            it('должен логировать действие', () => {
                const subscription: Subscription = {
                    id: 'test-sub',
                    userId: mockUserId,
                    tier: 'premium',
                    status: 'active',
                    currentPeriodStart: new Date(),
                    currentPeriodEnd: new Date(),
                    cancelAtPeriodEnd: false,
                    createdAt: new Date(),
                    updatedAt: new Date()
                }

                addMockSubscription(subscription)

                expect(mockConsoleLog).toHaveBeenCalledWith(
                    '🧪 MOCK РЕЖИМ: Добавление тестовой подписки'
                )
            })
        })
    })
})
